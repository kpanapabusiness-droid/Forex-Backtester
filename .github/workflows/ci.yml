name: CI
on:
  pull_request:
  push:
jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Write early diagnostics so we have data even if setup fails
      - name: Diagnostics (early)
        id: diag
        shell: bash
        run: |
          set +e
          : > diag.log
          {
            echo "Runner: $RUNNER_OS"
            uname - a || true
            which python || true
            which python3 || true
            python --version || true
            python3 --version || true
            which pip || true
            pip --version || true
          } 2>&1 | tee -a diag.log

      # If setup ever hiccups, we still run later steps
      - name: Setup Python
        id: setup
        uses: actions/setup-python@v5
        continue-on-error: true
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install
        id: install
        shell: bash
        run: |
          set -e
          python -m pip install -U pip
          # Minimal deps to satisfy tests/conftest + core suite
          pip install -U pytest ruff numpy pandas
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi

      - name: Ruff
        id: ruff
        shell: bash
        run: |
          set +e
          set -o pipefail
          : > ruff.log
          ruff check . 2>&1 | tee -a ruff.log
          echo "RUFF_EXIT=${PIPESTATUS[0]}" >> "$GITHUB_OUTPUT"
          exit 0

      - name: Pytest (full suite, clean env)
        id: pytest
        env:
          PYTEST_DISABLE_PLUGIN_AUTOLOAD: "1"
          PYTHONPATH: ${{ github.workspace }}
        shell: bash
        run: |
          set +e
          set -o pipefail
          : > pytest.log
          python -m pytest -q -c /dev/null 2>&1 | tee -a pytest.log
          echo "PYTEST_EXIT=${PIPESTATUS[0]}" >> "$GITHUB_OUTPUT"
          exit 0

      - name: Smoke (non-gating)
        id: smoke
        shell: bash
        run: |
          set +e
          set -o pipefail
          : > smoke.log
          if [ -f smoke_test_full_v198.py ]; then python smoke_test_full_v198.py 2>&1 | tee -a smoke.log; fi
          echo "SMOKE_EXIT=${PIPESTATUS[0]:-0}" >> "$GITHUB_OUTPUT"
          exit 0

      # Gate merges on ruff + pytest only
      - name: Fail at end if needed (gate on ruff+pytest)
        if: always()
        shell: bash
        run: |
          r="${{ steps.ruff.outputs.RUFF_EXIT }}"
          p="${{ steps.pytest.outputs.PYTEST_EXIT }}"
          echo "gates: ruff=$r pytest=$p"
          if [ "$r" != "0" ] || [ "$p" != "0" ]; then exit 1; fi

      # Always evaluate, but only send to Discord when the overall job actually failed
      - name: Notify Discord on failure
        if: failure()
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        shell: bash
        run: |
          python - <<'PY'
          import os, json, urllib.request
          run_url = os.environ["RUN_URL"]
          webhook = os.environ["DISCORD_WEBHOOK"]
          payload = json.dumps({"content": f"❌ CI failed! See run: {run_url}"}).encode()
          req = urllib.request.Request(webhook, data=payload, headers={"Content-Type":"application/json"})
          with urllib.request.urlopen(req) as resp:
              print(resp.status)
          PY
